---
layout: post
title:  "2021.04.27. Learning Log"
---

# Kewords

- 메모리의 저장구조
(Top)        machine code
             global
             heap
(Bottom)     stack

-포인터의 의미
(*와 &의 쓰임)
-get_string의 구성
-FILE이라는 자료형
-fopen("", "a || r || w")
-fprintf, fclose



# 공부하며 느낀 주의점 및 깨달은 점

1. 포인터의 의미(헷갈리지말자)
 - &의 쓰임: 주소값을 반환해줄 때 사용된다.(~의 주소라는 의미)
 - *의 첫 번째 쓰임: 자료형 하나와 같이 붙으면 변수가 포인터임을 나타내주는 자료형
                  ex) int *p = i;(int를 가리킬 수 있는 포인터인 p)
 - *의 두 번째 쓰임: *만 쓰인다면 포인터가 기리키는 값을 의미(포인터가 가리키는 주소로가!)
 
2. 문자열 자체가 포인터의 역할이되기도 한다.
    char s[5] // char *s = NULL 로하면 안되는 이유 -> 's가 가리키는 곳(메모리의 s포인터영역에)에 아무것도 할당하지 않았다'가 되어버림 /
              // 그래서 char s[5]로 5칸을 할당해준거야
    printf("s: ");
    scanf("%s", s); // 그러면 왜 s의 주소인 &s로 하지 않지? 복사본이 안두려워? -> 위를 보면 s는 문자열이야 문자열은 연속된 문자가 연속적으로 저장되있어
                    // 즉, 그 문자열 자체가 문자열의 첫 번째 항목을 의미해서 포인터로써 역할이 가능해
    printf("s: %s\n", s);

3. 포인터가 참조할 주소를 설정해놓지 않으면 포인터가 참조하는 주소가 쓰레기값이된다.
그래서 접근이 허용되지 않는 주소에 대한 참조로는 segmentation fault가 뜬다.
즉, 방향성을 잃어서 임의로 가다가 의도치 않은 주소나 접근 불가능 한 곳으로 지정해서 가니까 오류가 뜬다.

4. heap과 stack은 둘 중 한쪽이 커지면 서로의 영역을 침범할 수 있다.
   만약 malloc을 많이 사용하여 heap의 영역이 너무 커져서 stack을 침범했다 == heap overflow
   반대로 재귀의 무분별한 사용으로 stack이 너무 커져 heap을 침범했다 == stack overflow
   
   
   
# 소감 및 메타인지

내가 공부하는 방식이 맞는건지 의문이 든다. 물론 비전공자이며 시작한지 얼마안되서 그럴 수 있겠지만 코딩이란건 결국 내가 설계할 수 있어야하는게 아닐까 생각한다.
지금은 cs50강의를 보면서 단순히 따라하거나 조금의 응용을 통한 코드를 작성하고 있는데 현재 단계로써는 이게 맞는 것일까? 아닐까? 고민해봐야 할 문제이다.
어떠한 코드를 읽을 때 정말 수학기호처럼 공식처럼 하려고 하지말고 그 코드가 컴퓨터한테 무슨말을 하려고하는지를 차근차근, 언어를 읽듯이 하는 습관을 더 들이자.
C언어를 중점으로 기본적인 컴퓨터 지식에 대해서 공부하고 있는데 역시 C는 쉽지않다. 그런데 쉽지않아서 오히려 더 재밌게 느껴지고 흥미가 생긴다.
항상 할 수 있다는 마음가짐으로 나의 성장에 집중하자. 내가 세운 목표인 개발자에 흥미와 재미가 느껴져서 요즘 내가 정말 살아있음을 느낀다.
목표의식을 가지고 배워나가는 것은 흥미로운 일이라는 것을 처음 느껴본다.
초심 잃지말고 이대로 꾸준하게!
